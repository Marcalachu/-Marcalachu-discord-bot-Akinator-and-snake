import discord
from discord.ext import commands
import json
import random
import asyncio

# ConfiguraciÃ³n del bot
TOKEN = 'TU_TOKEN_AQUI'  # Reemplaza con tu token de Discord

intents = discord.Intents.default()
intents.message_content = True  # Habilitar el intent de contenido de mensajes
bot = commands.Bot(command_prefix='!', intents=intents)

# Cargar el Ã¡rbol de decisiones desde un archivo JSON
def load_decision_tree():
    try:
        with open('decision_tree.json', 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        # Si no existe el archivo, se crea un Ã¡rbol de decisiones inicial
        return {
            "Â¿Es un personaje real?": {
                "sÃ­": {
                    "Â¿Es un cientÃ­fico?": {
                        "sÃ­": {
                            "Â¿Es conocido por su trabajo en fÃ­sica?": {
                                "sÃ­": "Albert Einstein",
                                "no": "Marie Curie"
                            }
                        },
                        "no": {
                            "Â¿Es un polÃ­tico?": {
                                "sÃ­": "Barack Obama",
                                "no": "Elon Musk"
                            }
                        }
                    },
                    "Â¿Es un artista?": {
                        "sÃ­": {
                            "Â¿Es un mÃºsico?": {
                                "sÃ­": "Freddie Mercury",
                                "no": "Pablo Picasso"
                            }
                        },
                        "no": {
                            "Â¿Es un deportista?": {
                                "sÃ­": {
                                    "Â¿Es un futbolista?": {
                                        "sÃ­": "Lionel Messi",
                                        "no": "Michael Jordan"
                                    }
                                },
                                "no": "Oprah Winfrey"
                            }
                        }
                    }
                },
                "no": {
                    "Â¿Es un superhÃ©roe?": {
                        "sÃ­": {
                            "Â¿Es de Marvel?": {
                                "sÃ­": "Spider-Man",
                                "no": "Batman"
                            }
                        },
                        "no": {
                            "Â¿Es un personaje de dibujos animados?": {
                                "sÃ­": {
                                    "Â¿Es de Disney?": {
                                        "sÃ­": "Mickey Mouse",
                                        "no": "Bugs Bunny"
                                    }
                                },
                                "no": "Shrek"
                            }
                        }
                    }
                }
            }
        }

# Guardar el Ã¡rbol de decisiones en un archivo JSON
def save_decision_tree(tree):
    with open('decision_tree.json', 'w') as f:
        json.dump(tree, f)

# Comando para jugar Akinator
@bot.command()
async def akinator(ctx):
    decision_tree = load_decision_tree()
    await ctx.send("Â¡Comencemos a jugar Akinator! Piensa en un personaje y yo intentarÃ© adivinarlo.")

    current_node = decision_tree

    while isinstance(current_node, dict):
        for question, answers in current_node.items():
            await ctx.send(question)
            def check(m):
                return m.author == ctx.author and m.channel == ctx.channel

            try:
                response = await bot.wait_for('message', check=check, timeout=15.0)
                await ctx.send(f"Tu respuesta: {response.content}")
                response = response.content.lower()

                # Normalizar respuestas
                if response in ["sÃ­", "si", "yes", "y"]:
                    response = "sÃ­"
                elif response in ["no", "n", "nope"]:
                    response = "no"
                else:
                    await ctx.send("No entendÃ­ tu respuesta. Por favor, responde 'sÃ­' o 'no'.")
                    continue

                if response in answers:
                    current_node = answers[response]
                else:
                    await ctx.send("No entendÃ­ tu respuesta. Por favor, responde 'sÃ­' o 'no'.")
                    continue
            except asyncio.TimeoutError:
                await ctx.send("Â¡Tiempo agotado! El juego ha terminado.")
                return

    # Adivinar el personaje
    guessed_character = current_node
    await ctx.send(f"Â¡Creo que el personaje en el que pensabas es {guessed_character}!")

    # Preguntar si el personaje es correcto
    await ctx.send("Â¿Es correcto? (sÃ­/no)")
    def check(m):
        return m.author == ctx.author and m.channel == ctx.channel

    try:
        response = await bot.wait_for('message', check=check, timeout=15.0)
        if response.content.lower() in ["sÃ­", "si", "yes", "y"]:
            await ctx.send("Â¡Genial! Me alegra haber adivinado correctamente.")
        elif response.content.lower() in ["no", "n", "nope"]:
            await ctx.send("Â¡Oh no! Â¿CuÃ¡l era el personaje?")
            new_character = await bot.wait_for('message', check=check, timeout=15.0)
            await ctx.send("Â¿QuÃ© pregunta podrÃ­a ayudarme a adivinarlo?")
            new_question = await bot.wait_for('message', check=check, timeout=15.0)

            # Actualizar el Ã¡rbol de decisiones
            decision_tree[new_question.content] = {
                "sÃ­": new_character.content,
                "no": guessed_character
            }
            save_decision_tree(decision_tree)  # Guardar el Ã¡rbol actualizado
            await ctx.send("Â¡Gracias! He aprendido algo nuevo.")
        else:
            await ctx.send("No entendÃ­ tu respuesta. Por favor, responde 'sÃ­' o 'no'.")
    except asyncio.TimeoutError:
        await ctx.send("Â¡Tiempo agotado! El juego ha terminado.")

# Comando para jugar Snake
snake_body = []
food_position = (0, 0)
snake_direction = "RIGHT"
snake_game_active = False
snake_players = 0  # Contador de jugadores en Snake

def render_board():
    board = ""
    for y in range(10):
        for x in range(10):
            if (x, y) in snake_body:
                board += "ğŸ"
            elif (x, y) == food_position:
                board += "ğŸ"
            else:
                board += "â¬œ"
        board += "\n"
    return board

def update_snake_position():
    global snake_body, food_position, snake_game_active
    head_x, head_y = snake_body[0]

    if snake_direction == "LEFT":
        head_x -= 1
    elif snake_direction == "RIGHT":
        head_x += 1
    elif snake_direction == "UP":
        head_y -= 1
    elif snake_direction == "DOWN":
        head_y += 1

    if head_x < 0 or head_x >= 10 or head_y < 0 or head_y >= 10 or (head_x, head_y) in snake_body:
        snake_game_active = False
        return

    if (head_x, head_y) == food_position:
        snake_body.insert(0, (head_x, head_y))
        food_position = (random.randint(0, 9), random.randint(0, 9))
    else:
        snake_body.insert(0, (head_x, head_y))
        snake_body.pop()

@bot.command()
async def snake(ctx):
    global snake_body, food_position, snake_direction, snake_game_active, snake_players
    snake_players += 1
    snake_body = [(0, 0)]
    food_position = (random.randint(0, 9), random.randint(0, 9))
    snake_direction = "RIGHT"
    snake_game_active = True

    await ctx.send("Â¡Comenzando el juego Snake! Usa las reacciones para moverte. ğŸğŸ")
    game_board = await ctx.send(render_board())
    await game_board.add_reaction("â¬…ï¸")
    await game_board.add_reaction("â¡ï¸")
    await game_board.add_reaction("â¬†ï¸")
    await game_board.add_reaction("â¬‡ï¸")

    while snake_game_active:
        def check(reaction, user):
            return user == ctx.author and str(reaction.emoji) in ["â¬…ï¸", "â¡ï¸", "â¬†ï¸", "â¬‡ï¸"]

        try:
            reaction, user = await bot.wait_for('reaction_add', check=check, timeout=10.0)
            if str(reaction.emoji) == "â¬…ï¸":
                snake_direction = "LEFT"
            elif str(reaction.emoji) == "â¡ï¸":
                snake_direction = "RIGHT"
            elif str(reaction.emoji) == "â¬†ï¸":
                snake_direction = "UP"
            elif str(reaction.emoji) == "â¬‡ï¸":
                snake_direction = "DOWN"
        except asyncio.TimeoutError:
            await ctx.send("Â¡Tiempo agotado! El juego ha terminado.")
            snake_game_active = False
            return